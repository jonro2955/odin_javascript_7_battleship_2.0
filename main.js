/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/aiHelpers.js":
/*!**************************!*\
  !*** ./src/aiHelpers.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst aiHelpers = () => {\n  /** getHitAdjacentCoordOf(bow, moves): \n  Check in moves if there is a hitmove that is adjacent to bow \n  that is not destroyed. If found, return that move. If not, return false. \n  bow format: { coord: { x: 0, y: 9 }, hitResult: true, destroyed: false }\n  The directions from bow to look for a hit move depends on bow's position*/\n  function getHitAdjacentCoord(bow, moves) {\n    let x = bow['coord']['x'];\n    let y = bow['coord']['y'];\n    let returnMove;\n    moves.forEach((move) => {\n      if (x === 0) {\n        // if x = 0 (bow is on left edge column), check right\n        if (\n          move['coord']['x'] === x + 1 &&\n          move['coord']['y'] === y &&\n          move['hitResult'] === true &&\n          move['destroyed'] === false\n        ) {\n          returnMove = move;\n        }\n      }\n      if (x === 9) {\n        //check left\n        if (\n          move['coord']['x'] === x - 1 &&\n          move['coord']['y'] === y &&\n          move['hitResult'] === true &&\n          move['destroyed'] === false\n        ) {\n          returnMove = move;\n        }\n      }\n      if (y === 0) {\n        //check below\n        if (\n          move['coord']['x'] === x &&\n          move['coord']['y'] === y + 1 &&\n          move['hitResult'] === true &&\n          move['destroyed'] === false\n        ) {\n          returnMove = move;\n        }\n      }\n      if (y === 9) {\n        //check above\n        if (\n          move['coord']['x'] === x &&\n          move['coord']['y'] === y - 1 &&\n          move['hitResult'] === true &&\n          move['destroyed'] === false\n        ) {\n          returnMove = move;\n        }\n      }\n      // //for all other inner cells, check all 4 sides\n      else {\n        //right\n        if (\n          move['coord']['x'] === x + 1 &&\n          move['coord']['y'] === y &&\n          move['hitResult'] === true &&\n          move['destroyed'] === false\n        ) {\n          returnMove = move;\n        }\n        //left\n        if (\n          move['coord']['x'] === x - 1 &&\n          move['coord']['y'] === y &&\n          move['hitResult'] === true &&\n          move['destroyed'] === false\n        ) {\n          returnMove = move;\n        }\n        //above\n        if (\n          move['coord']['x'] === x &&\n          move['coord']['y'] === y + 1 &&\n          move['hitResult'] === true &&\n          move['destroyed'] === false\n        ) {\n          returnMove = move;\n        }\n        //below\n        if (\n          move['coord']['x'] === x &&\n          move['coord']['y'] === y - 1 &&\n          move['hitResult'] === true &&\n          move['destroyed'] === false\n        ) {\n          returnMove = move;\n        }\n      }\n    });\n    return returnMove;\n  }\n\n  /**Using given moves, return board.receiveAttack(coord) with the \n  coord of one of the cells adjacent to bow that has not been played. \n  */\n  function hitAdjacent(bow, moves, board) {\n    const directions = ['n', 's', 'w', 'e'];\n    let blocked = [];\n    let x = bow['coord']['x'];\n    let y = bow['coord']['y'];\n    moves.forEach((move) => {\n      //If bow is on the left edge, block west. Do the same for other 3 edges.\n      if (x === 9) {\n        blocked.push('e');\n      }\n      if (x === 0) {\n        blocked.push('w');\n      }\n      if (y === 0) {\n        blocked.push('n');\n      }\n      if (y === 9) {\n        blocked.push('s');\n      }\n      //if theres a move to the east, block east. do the same for ther 3 directions\n      if (move['coord']['x'] === x + 1 && move['coord']['y'] === y) {\n        blocked.push('e');\n      }\n      if (move['coord']['x'] === x - 1 && move['coord']['y'] === y) {\n        blocked.push('w');\n      }\n      if (move['coord']['x'] === x && move['coord']['y'] === y - 1) {\n        blocked.push('n');\n      }\n      if (move['coord']['x'] === x && move['coord']['y'] === y + 1) {\n        blocked.push('s');\n      }\n    });\n    let options = directions.filter((x) => !blocked.includes(x));\n    let direction = options[0];\n    let coord, hitResult;\n    switch (direction) {\n      case 'e':\n        coord = { x: x + 1, y: y };\n        hitResult = board.receiveAttack(coord);\n        moves.push({ coord: coord, hitResult: hitResult, destroyed: false });\n        console.log('hitAdjacent(): ', coord, 'hitResult: ', hitResult);\n        return hitResult;\n      case 'w':\n        coord = { x: x - 1, y: y };\n        hitResult = board.receiveAttack(coord);\n        moves.push({ coord: coord, hitResult: hitResult, destroyed: false });\n        console.log('hitAdjacent(): ', coord, 'hitResult: ', hitResult);\n        return hitResult;\n      case 'n':\n        coord = { x: x, y: y - 1 };\n        hitResult = board.receiveAttack(coord);\n        moves.push({ coord: coord, hitResult: hitResult, destroyed: false });\n        console.log('hitAdjacent(): ', coord, 'hitResult: ', hitResult);\n        return hitResult;\n      case 's':\n        coord = { x: x, y: y + 1 };\n        hitResult = board.receiveAttack(coord);\n        moves.push({ coord: coord, hitResult: hitResult, destroyed: false });\n        console.log('hitAdjacent(): ', coord, 'hitResult: ', hitResult);\n        return hitResult;\n    }\n  }\n\n  /*CURRENT: return coordinates for an open endcoord of enemyShip, if it\n  exists. Return value format: {x:1, y:0}*/\n  function getHitOption(enemyShip, moves, vertical) {\n    let returnVal;\n    const bow = enemyShip[0];\n    const stern = enemyShip[enemyShip.length - 1];\n    const bowX = bow['coord']['x'];\n    const bowY = bow['coord']['y'];\n    const sternX = stern['coord']['x'];\n    const sternY = stern['coord']['y'];\n    console.log('bow: ', bow['coord'], 'stern: ', stern['coord']);\n    if (vertical) {\n      //first the above cell\n      returnVal = { x: bowX, y: bowY - 1 };\n      moves.forEach((move) => {\n        if (\n          bowY == 0 ||\n          (move['coord']['x'] === bowX && move['coord']['y'] === bowY - 1)\n        ) {\n          returnVal = false;\n        }\n      });\n      //if that didn't work, try below\n      if (returnVal === false) {\n        returnVal = { x: sternX, y: sternY + 1 };\n        moves.forEach((move) => {\n          if (\n            sternY == 9 ||\n            (move['coord']['x'] === sternX && move['coord']['y'] === sternY + 1)\n          ) {\n            returnVal = false;\n          }\n        });\n      }\n    } else {\n      /*Horizontal cases. First the left cell*/\n      returnVal = { x: bowX - 1, y: bowY };\n      moves.forEach((move) => {\n        if (\n          bowX == 0 ||\n          (move['coord']['x'] === bowX - 1 && move['coord']['y'] === bowY)\n        ) {\n          returnVal = false;\n        }\n      });\n      //if that didn't work, try the right side\n      if (returnVal === false) {\n        returnVal = { x: sternX + 1, y: sternY };\n        moves.forEach((move) => {\n          if (\n            sternX == 9 ||\n            (move['coord']['x'] === sternX + 1 && move['coord']['y'] === sternY)\n          ) {\n            returnVal = false;\n          }\n        });\n      }\n    }\n\n    console.log('getHitOption returnVal: ', returnVal);\n    /*And if returnVal is false, we need to set all enemyShip's coords \n    in 'moves' to 'destroyed' */\n    if (!returnVal) {\n      moves.forEach((move) => {\n        enemyShip.forEach((shipPart) => {\n          if (move['coord'] == shipPart['coord']) {\n            move['destroyed'] = true;\n          }\n        });\n      });\n      enemyShip = [];\n    }\n\n    return returnVal;\n  }\n\n  /**\n  enemyShip input has 2 sorted hit cells inside. If there are adjacent cells\n  inside moves array along the current orientation of enemyShip, add them to \n  enemyShip\n   */\n  function fillUpEnemyShip(enemyShip, moves) {\n    let bow = enemyShip[0];\n    let stern = enemyShip[1];\n    let bowX, bowY, sternX, sternY;\n    let vertical = bow['coord']['y'] - stern['coord']['y'];\n    if (vertical) {\n      //first the above cells\n      moves.forEach((move) => {\n        bowX = bow['coord']['x'];\n        bowY = bow['coord']['y'];\n        if (\n          bowY > 0 &&\n          move['coord']['x'] === bowX &&\n          move['coord']['y'] === bowY - 1 &&\n          move['hitResult'] === true &&\n          move['destroyed'] === false\n        ) {\n          bow = move;\n          enemyShip.unshift(move);\n        }\n      });\n      //then, do same for below\n      moves.forEach((move) => {\n        sternX = stern['coord']['x'];\n        sternY = stern['coord']['y'];\n        if (\n          sternY < 9 &&\n          move['coord']['x'] === sternX &&\n          move['coord']['y'] === sternY + 1 &&\n          move['hitResult'] === true &&\n          move['destroyed'] === false\n        ) {\n          stern = move;\n          enemyShip.push(move);\n        }\n      });\n    } else {\n      /*Horizontal cases. First the left cell*/\n      moves.forEach((move) => {\n        bowX = bow['coord']['x'];\n        bowY = bow['coord']['y'];\n        if (\n          bowX > 0 &&\n          move['coord']['x'] === bowX - 1 &&\n          move['coord']['y'] === bowY &&\n          move['hitResult'] === true &&\n          move['destroyed'] === false\n        ) {\n          bow = move;\n          enemyShip.unshift(move);\n        }\n      });\n      //then, do same for below\n      moves.forEach((move) => {\n        sternX = stern['coord']['x'];\n        sternY = stern['coord']['y'];\n        if (\n          sternX < 9 &&\n          move['coord']['x'] === sternX + 1 &&\n          move['coord']['y'] === sternY &&\n          move['hitResult'] === true &&\n          move['destroyed'] === false\n        ) {\n          stern = move;\n          enemyShip.push(move);\n        }\n      });\n    }\n  }\n\n  return {\n    getHitAdjacentCoord,\n    hitAdjacent,\n    getHitOption,\n    fillUpEnemyShip,\n  };\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (aiHelpers);\n\n\n//# sourceURL=webpack://odin_javascript_7_battleship/./src/aiHelpers.js?");

/***/ }),

/***/ "./src/data.js":
/*!*********************!*\
  !*** ./src/data.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst data = () => {\n\n  const fleet = [\n    { id: 'Patrol', length: 2 },\n    { id: 'Submarine', length: 3 },\n    { id: 'Cruiser', length: 3 },\n    { id: 'Battleship', length: 4 },\n    { id: 'Carrier', length: 5 },\n  ];\n\n  return { fleet };\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (data);\n\n\n//# sourceURL=webpack://odin_javascript_7_battleship/./src/data.js?");

/***/ }),

/***/ "./src/dom.js":
/*!********************!*\
  !*** ./src/dom.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst dom = () => {\n  const humanBox = document.querySelector('#humanBox');\n  const computerBox = document.querySelector('#computerBox');\n  const gameScreen = document.querySelector('#gameScreen');\n  const restartBtn = document.querySelector('#restartBtn');\n  const messageH = document.querySelector('#messageH');\n  const messageC = document.querySelector('#messageC');\n\n  function renderBoards(humanBoard, computerBoard) {\n    const humanGrid = createGrid(humanBoard);\n    humanBox.append(humanGrid);\n    humanGrid.setAttribute('id', 'humanGrid');\n    const computerGrid = createGrid(computerBoard);\n    computerBox.append(computerGrid);\n    computerGrid.setAttribute('id', 'computerGrid');\n    gameScreen.style.display = 'flex';\n    restartBtn.style.display = 'initial';\n    document.querySelectorAll('.boardLabel').forEach((elem) => {\n      elem.style.display = 'initial';\n    });\n  }\n\n  function createGrid(gameBoard) {\n    const grid = document.createElement('div');\n    grid.classList.add('grid');\n    for (let x = 0; x < 10; x++) {\n      const column = document.createElement('span');\n      column.classList.add('column');\n      grid.append(column);\n      for (let y = 0; y < 10; y++) {\n        const cell = document.createElement('div');\n        cell.classList.add('cell');\n        const cellID = gameBoard.getBoardID() + x + y;\n        cell.setAttribute('id', cellID);\n        cell.setAttribute('data-column', x);\n        cell.setAttribute('data-row', y);\n        //this if stmt makes only the human's board show ships\n        if (gameBoard.getBoardID() === 'human') {\n          //if the cell has a shipID key, it's occupied by a ship\n          if (gameBoard.getBoard()[x][y]['shipID']) {\n            cell.classList.add('occupiedCell');\n          }\n        }\n        column.append(cell);\n      }\n    }\n    return grid;\n  }\n\n  function removeExistingBoards() {\n    humanBox.innerHTML = '';\n    computerBox.innerHTML = '';\n    document.querySelectorAll('.boardLabel').forEach((label) => {\n      label.style.display = 'none';\n    });\n  }\n\n  function activateAttackGrid(fn) {\n    computerBox.querySelectorAll('.cell').forEach((cell) => {\n      cell.addEventListener('click', fn, { once: true });\n    });\n  }\n\n  function activateAIBtn(fn) {\n    aiToggle.addEventListener('click', fn);\n  }\n\n  function announceMsgH(msg) {\n    messageH.textContent = msg;\n    setTimeout(() => {\n      messageH.textContent = '';\n    }, 500);\n  }\n\n  function announceMsgC(msg) {\n    messageC.textContent = msg;\n    setTimeout(() => {\n      messageC.textContent = '';\n    }, 500);\n  }\n\n  function markComputerBoardHit(clickedTarget) {\n    clickedTarget.classList.add('hit');\n  }\n\n  function markComputerBoardMiss(clickedTarget) {\n    clickedTarget.classList.add('miss');\n  }\n\n  function markHumanBoardHit(coord) {\n    let x = coord['x'];\n    let y = coord['y'];\n    const concatCoord = 'human' + x.toString() + y.toString();\n    document.getElementById(concatCoord).classList.add('hit');\n  }\n\n  function markHumanBoardMiss(coord) {\n    const x = coord['x'];\n    const y = coord['y'];\n    const concatCoord = 'human' + x.toString() + y.toString();\n    document.getElementById(concatCoord).classList.add('miss');\n  }\n\n  function announceGameOver(msg) {\n    document.getElementById('gameOverMsg').textContent = msg;\n  }\n\n  function clearAll() {\n    announceMsgH('');\n    removeExistingBoards();\n    announceGameOver('');\n    computerSunkList.textContent = '';\n    humanSunkList.textContent = '';\n  }\n\n  function updateHumanSunk(board) {\n    const computerSunkList = document.querySelector('#computerSunkList');\n    computerSunkList.textContent = '';\n    let sunkShipsArray = board.getSunkShipsArray();\n    sunkShipsArray.forEach((sunkShip) => {\n      const elem = document.createElement('div');\n      elem.textContent = `${sunkShip.getID()} Sunk\\n`;\n      computerSunkList.prepend(elem);\n    });\n  }\n\n  function updateComputerSunk(board) {\n    const humanSunkList = document.querySelector('#humanSunkList');\n    humanSunkList.textContent = '';\n    let sunkShipsArray = board.getSunkShipsArray();\n    sunkShipsArray.forEach((sunkShip) => {\n      const elem = document.createElement('div');\n      elem.textContent = `${sunkShip.getID()} Sunk\\n`;\n      humanSunkList.prepend(elem);\n    });\n  }\n\n  return {\n    renderBoards,\n    activateAttackGrid,\n    announceMsgH,\n    announceMsgC,\n    removeExistingBoards,\n    markComputerBoardHit,\n    markComputerBoardMiss,\n    markHumanBoardHit,\n    markHumanBoardMiss,\n    activateAIBtn,\n    announceGameOver,\n    clearAll,\n    updateHumanSunk,\n    updateComputerSunk,\n  };\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dom);\n\n\n//# sourceURL=webpack://odin_javascript_7_battleship/./src/dom.js?");

/***/ }),

/***/ "./src/dragNDrop.js":
/*!**************************!*\
  !*** ./src/dragNDrop.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _src_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/data */ \"./src/data.js\");\n\n\n/**dragNDrop(hBoard, startGameCallBack):\n * @param hBoard: gameBoard object.\n * @param startGameCallBack: A callback function to start the game once\n * the hBoard is populated.\n */\nconst dragNDrop = (hBoard, startGameCallBack) => {\n  /**\n  1. Display a setup grid \n  */\n  const humanSetupGrid = document.querySelector('#humanSetupGrid');\n  //first clear humanSetupGrid, since dragNDrop() will be reused on restarts\n  humanSetupGrid.innerHTML = '';\n  const setupBoardLabel = document.createElement('div');\n  humanSetupGrid.append(setupBoardLabel);\n  const setupContainer = document.createElement('div');\n  setupContainer.classList.add('grid');\n  for (let x = 0; x < 10; x++) {\n    const column = document.createElement('span');\n    column.classList.add('column');\n    setupContainer.append(column);\n    for (let y = 0; y < 10; y++) {\n      const cell = document.createElement('div');\n      cell.classList.add('cell');\n      const cellID = 'setup' + x + y;\n      cell.setAttribute('id', cellID);\n      cell.setAttribute('data-column', x);\n      cell.setAttribute('data-row', y);\n      column.append(cell);\n    }\n  }\n  humanSetupGrid.append(setupContainer);\n  humanSetupGrid.style.display = 'initial';\n\n  /**\n  2. Insert and wire up the orientation toggle button\n  */\n  const orientationBtn = document.createElement('button');\n  orientationBtn.setAttribute('id', 'orientationBtn');\n  orientationBtn.textContent = 'Horizontal';\n  humanSetupGrid.append(orientationBtn);\n  orientationBtn.addEventListener('click', () => {\n    if (orientationBtn.textContent !== 'Horizontal') {\n      orientationBtn.textContent = 'Horizontal';\n    } else {\n      orientationBtn.textContent = 'Vertical';\n    }\n  });\n\n  /**\n  3. Put hover listeners in each cell so that upon hover,  \n  we get a pre-rendering of the current ship.\n  \n  If the user hovers to a cell which cannot be used as the origin \n  of the current ship as it will not fit, then there should be no \n  pre-rendering.\n  */\n\n  /**setMouseListeners(shipNum, hBoard):\n   * https://jsdoc.app/about-getting-started.html \n\n   * @param shipNum: A number used to access a ship in Data().fleet\n   * @param hBoard: gameBoard object passed in from the parent function\n   *\n   * Adds mouse event listeners to cells in humanSetupGrid.\n   *\n   * On hover, the proposed ship cells are highlighted given\n   * the current ship's length and its orientation (if it fits).\n   *\n   * On click, the ship gets placed on the hBoard if it fits.\n   * If it did fit, currentShip # is reduced by 1 and the function will\n   * call itself with this new reduced parameter to replace the mouse\n   * event listeners for the next ship in the fleet.\n   *\n   * On the first click, it will place ship #4, the carrier,\n   * then it will call itself with a new parameter, shipNum = 3.\n   * Once all 5 ships have been placed (when shipNum = -1), the\n   * callback startGameCallBack() is called to run the startGamePlay()\n   * function in index.js\n   */\n  function setMouseListeners(shipNum, hBoard) {\n    setupBoardLabel.textContent = `Place ${(0,_src_data__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().fleet[shipNum]['id']}`;\n    setupBoardLabel.setAttribute('class', 'blink');\n    humanSetupGrid.querySelectorAll('.cell').forEach((cell) => {\n      cell.onmouseover = () => {\n        //preview ship placement if it fits at currently hovered cell\n        let startingCoord = {\n          x: cell.getAttribute('data-column'),\n          y: cell.getAttribute('data-row'),\n        };\n        let vessel = (0,_src_data__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().fleet[shipNum];\n        let isVertical =\n          orientationBtn.textContent === 'Horizontal' ? true : false;\n        let coords = hBoard.calculateCoords(startingCoord, vessel, isVertical);\n        if (hBoard.fitsInBoard(coords)) {\n          coords.forEach((coord) => {\n            let x = coord['x'];\n            let y = coord['y'];\n            let id = 'setup' + x + y;\n            document.getElementById(id).classList.add('proposedCell');\n          });\n        }\n      };\n      cell.onmouseout = () => {\n        //remove preview highlighting from all cells on mouseout\n        humanSetupGrid.querySelectorAll('.cell').forEach((cell) => {\n          cell.classList.remove('proposedCell');\n        });\n      };\n      cell.onclick = () => {\n        //place ship at clicked cell if it fits\n        let startingCoord = {\n          x: cell.getAttribute('data-column'),\n          y: cell.getAttribute('data-row'),\n        };\n        let vessel = (0,_src_data__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().fleet[shipNum];\n        let isVertical =\n          orientationBtn.textContent === 'Horizontal' ? true : false;\n        let placedCoords = hBoard.placeShip(startingCoord, vessel, isVertical);\n        if (placedCoords) {\n          hBoard.makeSurroundingCellsUnavailable(placedCoords);\n          currentShip--;\n          //mark occupied cells\n          placedCoords.forEach((coord) => {\n            let x = coord['x'];\n            let y = coord['y'];\n            let id = 'setup' + x + y;\n            document.getElementById(id).classList.remove('proposedCell');\n            document.getElementById(id).classList.add('occupiedCell');\n          });\n        }\n        if (currentShip >= 0) {\n          //reset cell listeners with new currentShip\n          setMouseListeners(currentShip, hBoard);\n        } else {\n          //start gameplay\n          humanSetupGrid.style.display = 'none';\n          startGameCallBack();\n        }\n      };\n    });\n  }\n\n  //starting ship number\n  let currentShip = 4;\n  setMouseListeners(currentShip, hBoard);\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dragNDrop);\n\n\n//# sourceURL=webpack://odin_javascript_7_battleship/./src/dragNDrop.js?");

/***/ }),

/***/ "./src/gameBoard.js":
/*!**************************!*\
  !*** ./src/gameBoard.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ship__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ship */ \"./src/ship.js\");\n/* harmony import */ var _src_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/data */ \"./src/data.js\");\n/**Must test fitsInBoard() */\n\n\n\n\nconst gameBoard = (name) => {\n  let board = initializeBoard();\n  let boardShips = [];\n  let sunkShipsArray = [];\n  let missedShots = [];\n  let id = name;\n\n  /**The board is an array of 10 arrays (columns) each having 10 cells\n   * that start out as { shipID: null, avail: true }. When a ship is placed,\n   * we'll give the 'shipID' property an actual string, the 'avail' property\n   * becomes false, and we give it a new property 'hit' which is initially\n   * false*/\n  function initializeBoard() {\n    let container = [];\n    for (let x = 0; x < 10; x++) {\n      let column = [];\n      for (let y = 0; y < 10; y++) {\n        column.push({ shipID: null, avail: true });\n      }\n      container.push(column);\n    }\n    return container;\n  }\n\n  /**This is needed to make the user place ships on the board so that they do \n   * not touch each other. For the current ai algorithm to work, the ships cannot \n   * touch.*/\n  function makeSurroundingCellsUnavailable(coords) {\n    coords.forEach((coord) => {\n      let x = coord['x'];\n      let y = coord['y'];\n      //top left corner cell: make east/southeast/south cells unavailable\n      if (x === 0 && y === 0) {\n        //e\n        board[x + 1][y]['avail'] = false;\n        //se\n        board[x + 1][y + 1]['avail'] = false;\n        //s\n        board[x][y + 1]['avail'] = false;\n      }\n      //top right corner\n      else if (x === 9 && y === 0) {\n        //s\n        board[x][y + 1]['avail'] = false;\n        //sw\n        board[x - 1][y + 1]['avail'] = false;\n        //w\n        board[x - 1][y]['avail'] = false;\n      }\n      //bottom left corner\n      else if (x === 0 && y === 9) {\n        //n\n        board[x][y - 1]['avail'] = false;\n        //ne\n        board[x + 1][y - 1]['avail'] = false;\n        //e\n        board[x + 1][y]['avail'] = false;\n      }\n      //bottom right corner\n      else if (x === 9 && y === 9) {\n        //w\n        board[x - 1][y]['avail'] = false;\n        //nw\n        board[x - 1][y - 1]['avail'] = false;\n        //n\n        board[x][y - 1]['avail'] = false;\n      }\n      //top row inner cells\n      else if (y === 0) {\n        //e\n        board[x + 1][y]['avail'] = false;\n        //se\n        board[x + 1][y + 1]['avail'] = false;\n        //s\n        board[x][y + 1]['avail'] = false;\n        //sw\n        board[x - 1][y + 1]['avail'] = false;\n        //w\n        board[x - 1][y]['avail'] = false;\n      }\n      //bottom row inner cells\n      else if (y === 9) {\n        //w\n        board[x - 1][y]['avail'] = false;\n        //nw\n        board[x - 1][y - 1]['avail'] = false;\n        //n\n        board[x][y - 1]['avail'] = false;\n        //ne\n        board[x + 1][y - 1]['avail'] = false;\n        //e\n        board[x + 1][y]['avail'] = false;\n      }\n      //left column inner cells\n      else if (x === 0) {\n        //n\n        board[x][y - 1]['avail'] = false;\n        //ne\n        board[x + 1][y - 1]['avail'] = false;\n        //e\n        board[x + 1][y]['avail'] = false;\n        //se\n        board[x + 1][y + 1]['avail'] = false;\n        //s\n        board[x][y + 1]['avail'] = false;\n      }\n      //right column inner cells\n      else if (x === 9) {\n        //s\n        board[x][y + 1]['avail'] = false;\n        //sw\n        board[x - 1][y + 1]['avail'] = false;\n        //w\n        board[x - 1][y]['avail'] = false;\n        //nw\n        board[x - 1][y - 1]['avail'] = false;\n        //n\n        board[x][y - 1]['avail'] = false;\n      }\n      //all else: full 360 degrees\n      else {\n        //n\n        board[x][y - 1]['avail'] = false;\n        //ne\n        board[x + 1][y - 1]['avail'] = false;\n        //e\n        board[x + 1][y]['avail'] = false;\n        //se\n        board[x + 1][y + 1]['avail'] = false;\n        //s\n        board[x][y + 1]['avail'] = false;\n        //sw\n        board[x - 1][y + 1]['avail'] = false;\n        //w\n        board[x - 1][y]['avail'] = false;\n        //nw\n        board[x - 1][y - 1]['avail'] = false;\n      }\n    });\n  }\n\n  /**Random placement without touching:\n   * Repeat the following 5 times for each ship in the fleet:\n   * 1. Place a ship randomly until it fits.\n   * 2. For each coordinate of this new ship, make all of its\n   * surrounding cells 'unavailable'. The corner and edge cells\n   * are not completely surrounded by cells, so you have to deal\n   * with them differently than the inner cells which has 8\n   * surrounding cells.*/\n  function shuffleAddShipsNoTouch() {\n    for (let i = 0; i < 5; i++) {\n      let coords = placeShipRandomly((0,_src_data__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().fleet[i]);\n      while (!coords) {\n        coords = placeShipRandomly((0,_src_data__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().fleet[i]);\n      }\n      makeSurroundingCellsUnavailable(coords);\n    }\n  }\n\n  /**ship input is one of the Data().fleet ships.\n   * Places the input ship at a random location and returns the\n   * coordinates of the ship or 'false' as per placeShip()*/\n  function placeShipRandomly(ship) {\n    let randomOrigin = {\n      x: Math.floor(Math.random() * 10),\n      y: Math.floor(Math.random() * 10),\n    };\n    let randomOrientation = Math.floor(Math.random() * 2);\n    return placeShip(randomOrigin, ship, randomOrientation);\n  }\n\n  /**startingCoord has form: {x:0, y:0}\n   * vessel is one of data.fleet objects like { id: 'patrol', length: 2 }\n   * isVertical is a boolean\n   * The function either places the ship with the given parameters and then\n   * returns the coordinates or returns false if the ship doesn't fit*/\n  function placeShip(startingCoord, vessel, isVertical) {\n    let coords = calculateCoords(startingCoord, vessel, isVertical);\n    if (fitsInBoard(coords)) {\n      coords.forEach((coord) => {\n        let x = coord['x'];\n        let y = coord['y'];\n        board[x][y]['shipID'] = vessel['id'];\n        board[x][y]['avail'] = false;\n        board[x][y]['hit'] = false;\n      });\n      boardShips.push((0,_ship__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(vessel['id'], coords));\n      return coords;\n    } else {\n      /**ship dn fit.*/\n      return false;\n    }\n  }\n\n  /**same inputs as placeShip(). Returns an array of coords like\n   * [ {x:0, y:0}, {x:0, y:1} ] */\n  function calculateCoords(startingCoord, vessel, isVertical) {\n    let coords = [];\n    for (let i = 0; i < vessel['length']; i++) {\n      if (isVertical) {\n        coords.push({\n          x: Number(startingCoord['x']),\n          y: Number(startingCoord['y']) + i,\n        });\n      } else {\n        coords.push({\n          x: Number(startingCoord['x']) + i,\n          y: Number(startingCoord['y']),\n        });\n      }\n    }\n    return coords;\n  }\n\n  /**Input format:  {x:1, y:0}. Takes a coordinate, checks if there\n   * is a ship on the board at that coordinate, and if there is,\n   * marks the corresponding board cell as 'hit', hits the corresponding\n   * board ship, and returns true. If there is no ship, returns false.*/\n  function receiveAttack(coord) {\n    let result;\n    let x = coord['x'],\n      y = coord['y'];\n    if (board[x][y]['shipID'] === null) {\n      //miss\n      missedShots.push(coord);\n      result = false;\n    } else if (board[x][y]['hit'] === false) {\n      //hit - Mark the board cell as hit\n      board[x][y]['hit'] = true;\n      result = true;\n      boardShips.forEach((ship) => {\n        //find the ship and hit it\n        if (ship.getID() === board[x][y]['shipID']) {\n          ship.hit({ x: x, y: y });\n          //if ship is then sunk, console.log\n          if (ship.isSunk()) {\n            // console.log(`${name}'s`, ship.getID(), ' is sunk');\n            sunkShipsArray.push(ship);\n            // console.log(sunkShips);\n          }\n        }\n      });\n    }\n    return result;\n  }\n\n  /**input format: array of coords like [ {x:0, y:0}, {x:0, y:1} ] */\n  function fitsInBoard(coordArray) {\n    let returnVal = true;\n    coordArray.forEach((coord) => {\n      let x = coord['x'],\n        y = coord['y'];\n      if (x < 0 || x > 9 || y < 0 || y > 9) {\n        //out of bounds\n        returnVal = false;\n      } else if (board[x][y]['avail'] === false) {\n        //occupied cell\n        returnVal = false;\n      }\n    });\n    return returnVal;\n  }\n\n  /**For testing */\n  function sampleAddShips() {\n    placeShip({ x: 1, y: 1 }, (0,_src_data__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().fleet[4], false);\n    placeShip({ x: 6, y: 3 }, (0,_src_data__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().fleet[3], false);\n    placeShip({ x: 2, y: 5 }, (0,_src_data__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().fleet[2], false);\n    placeShip({ x: 3, y: 7 }, (0,_src_data__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().fleet[1], false);\n    placeShip({ x: 4, y: 9 }, (0,_src_data__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().fleet[0], false);\n  }\n\n  function allSunk() {\n    return boardShips.every((ship) => {\n      return ship.isSunk();\n    });\n  }\n\n  function getBoard() {\n    return board;\n  }\n\n  function getBoardShips() {\n    return boardShips;\n  }\n\n  function getBoardID() {\n    return id;\n  }\n\n  function getSunkShipsArray() {\n    return sunkShipsArray;\n  }\n\n  function reset() {\n    board = initializeBoard();\n    boardShips = [];\n    missedShots = [];\n    sunkShipsArray = [];\n  }\n\n  return {\n    getBoard,\n    calculateCoords,\n    placeShip,\n    allSunk,\n    receiveAttack,\n    getBoardShips,\n    fitsInBoard,\n    reset,\n    getBoardID,\n    sampleAddShips,\n    shuffleAddShipsNoTouch,\n    getSunkShipsArray,\n    makeSurroundingCellsUnavailable,\n  };\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (gameBoard);\n\n\n//# sourceURL=webpack://odin_javascript_7_battleship/./src/gameBoard.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _player_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./player.js */ \"./src/player.js\");\n/* harmony import */ var _gameBoard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gameBoard */ \"./src/gameBoard.js\");\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom */ \"./src/dom.js\");\n/* harmony import */ var _dragNDrop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dragNDrop */ \"./src/dragNDrop.js\");\n\n\n\n\n\nconst human = (0,_player_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\nconst computer = (0,_player_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\nconst humanBoard = (0,_gameBoard__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('human');\nconst computerBoard = (0,_gameBoard__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('computer');\nconst dom = (0,_dom__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\nconst restartBtn = document.querySelector('#restartBtn');\nlet gameOver = false;\nlet aiOn = true;\n\nconst aiBtn = document.querySelector('#aiBtn');\naiBtn.addEventListener('click', () => {\n  if (aiBtn.textContent === 'AI: On') {\n    aiBtn.textContent = 'AI: Off';\n    aiOn = false;\n  } else {\n    aiBtn.textContent = 'AI: On';\n    aiOn = true;\n  }\n});\n\nfunction shuffleModeStart() {\n  gameOver = false;\n  dom.clearAll();\n  human.reset();\n  humanBoard.reset();\n  computer.reset();\n  computerBoard.reset();\n  humanBoard.shuffleAddShipsNoTouch();\n  computerBoard.shuffleAddShipsNoTouch();\n  dom.renderBoards(humanBoard, computerBoard);\n  dom.activateAttackGrid(playerMove);\n}\n\nfunction dragNDropModeStart() {\n  restartBtn.style.display = 'none';\n  aiBtn.style.display = 'none';\n  gameOver = false;\n  dom.clearAll();\n  human.reset();\n  humanBoard.reset();\n  computer.reset();\n  computerBoard.reset();\n  computerBoard.shuffleAddShipsNoTouch();\n  (0,_dragNDrop__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(humanBoard, activateGame);\n}\n\nfunction activateGame() {\n  dom.renderBoards(humanBoard, computerBoard);\n  dom.activateAttackGrid(playerMove);\n  restartBtn.style.display = 'initial';\n  aiBtn.style.display = 'initial';\n}\n\nfunction playerMove(e) {\n  if (!gameOver) {\n    const x = Number(e.target.getAttribute('data-column'));\n    const y = Number(e.target.getAttribute('data-row'));\n    const isHit = human.attack({ x, y }, computerBoard);\n    if (isHit) {\n      dom.markComputerBoardHit(e.target);\n      dom.announceMsgH('HIT');\n      dom.updateComputerSunk(computerBoard);\n    } else {\n      dom.markComputerBoardMiss(e.target);\n      dom.announceMsgH('MISS');\n    }\n    if (computerBoard.allSunk()) {\n      gameOver = true;\n      dom.announceGameOver('Player Wins! Game Over');\n      restartBtn.style.display = 'initial';\n    } else {\n      //insert timeout here\n      // computerMove();\n      setTimeout(computerMove, 200);\n    }\n  }\n}\n\nfunction computerMove() {\n  let attackResult;\n  if (!gameOver) {\n    if (aiOn) {\n      attackResult = computer.smartAttack(humanBoard);\n    } else {\n      attackResult = computer.randomAttack(humanBoard);\n    }\n    const lastMoveCoord =\n      computer.getMoves()[computer.getMoves().length - 1]['coord'];\n    if (attackResult) {\n      dom.markHumanBoardHit(lastMoveCoord);\n      dom.announceMsgC('HIT');\n      dom.updateHumanSunk(humanBoard);\n    } else {\n      dom.markHumanBoardMiss(lastMoveCoord);\n      dom.announceMsgC('MISS');\n    }\n    if (humanBoard.allSunk()) {\n      gameOver = true;\n      dom.announceGameOver('Computer Wins! Game Over');\n      restartBtn.style.display = 'initial';\n    }\n  }\n}\n\nrestartBtn.addEventListener('click', dragNDropModeStart);\ndragNDropModeStart();\n\n\n//# sourceURL=webpack://odin_javascript_7_battleship/./src/index.js?");

/***/ }),

/***/ "./src/player.js":
/*!***********************!*\
  !*** ./src/player.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _aiHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aiHelpers */ \"./src/aiHelpers.js\");\n\n\nconst player = () => {\n  let moves = [];\n\n  function reset() {\n    moves = [];\n  }\n\n  /**coord input form:  {x:1, y:0}\n   * board is a gameBoard object*/\n  function attack(coord, board) {\n    let hitResult = board.receiveAttack(coord);\n    /*duplicates are eliminated by the { once: true } param inside \n    the addEventListener() of dom.activateAttackGrid(fn) */\n    moves.push({ coord: coord, hitResult: hitResult, destroyed: false });\n    return hitResult;\n  }\n\n  function randomAttack(board) {\n    // generateRandomCoord() returns a coord with form { x: 0, y: 9 }\n    let randomCoord = generateRandomCoord();\n    while (movesContainsCoord(moves, randomCoord)) {\n      randomCoord = generateRandomCoord();\n    }\n    let hitResult = board.receiveAttack(randomCoord);\n    moves.push({ coord: randomCoord, hitResult: hitResult, destroyed: false });\n    console.log('ramdomAttack: ', randomCoord, 'result: ', hitResult);\n    return hitResult;\n  }\n\n  /**************************************************************************\n   * @smartAttack\n   * @param board: a gameBoard object\n   * @returns a boolean indicating \"hit\" (true) or \"miss\" (false),\n   * which is a function of a function such as randomAttack(board),\n   * hitAdjacent(bow, moves, board), or attack(coord, board)\n   *************************************************************************/\n  function smartAttack(board) {\n    let enemyShip = [];\n\n    if (moves.length === 0) {\n      //step 1(a)\n      return randomAttack(board);\n    }\n\n    //array.find() returns the first match or returns undefined\n    let bow = moves.find((move) => {\n      return move['hitResult'] === true && move['destroyed'] === false;\n    });\n\n    if (bow === undefined) {\n      //step 1(b)\n      return randomAttack(board);\n    } else {\n      //step 2\n      enemyShip.push(bow);\n    }\n\n    // step 3:\n    let stern = (0,_aiHelpers__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().getHitAdjacentCoord(bow, moves);\n    if (!stern) {\n      //step 3(b)\n      return (0,_aiHelpers__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().hitAdjacent(bow, moves, board);\n    } else {\n      enemyShip.push(stern);\n    }\n\n    //step 4:\n    let vertical = enemyShip[0]['coord']['y'] - enemyShip[1]['coord']['y'];\n    //sort\n    if (vertical) {\n      enemyShip.sort((a, b) => {\n        return a['coord']['y'] - b['coord']['y'];\n      });\n    } else {\n      enemyShip.sort((a, b) => {\n        return a['coord']['x'] - b['coord']['x'];\n      });\n    }\n    (0,_aiHelpers__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().fillUpEnemyShip(enemyShip, moves); //tbd\n    console.log('enemyShip: ', enemyShip);\n    let hitOptionCoord = (0,_aiHelpers__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().getHitOption(enemyShip, moves, vertical); //current\n    if (hitOptionCoord) {\n      return attack(hitOptionCoord, board);\n    } else {\n      //Here mark all enemyShip coords in moves as 'destroyed'\n      return randomAttack(board);\n    }\n  } //smartAttack end\n\n  function movesContainsCoord(movesArray, coord) {\n    return movesArray.some((move) => {\n      return (\n        move['coord']['x'] === coord['x'] && move['coord']['y'] === coord['y']\n      );\n    });\n  }\n\n  function generateRandomCoord() {\n    let randomX = Math.floor(Math.random() * 10);\n    let randomY = Math.floor(Math.random() * 10);\n    return { x: randomX, y: randomY };\n  }\n\n  function getMoves() {\n    return moves;\n  }\n\n  return {\n    reset,\n    attack,\n    randomAttack,\n    generateRandomCoord,\n    getMoves,\n    smartAttack,\n  };\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (player);\n\n/**note: the { once: true } options in dom event listener prevents\n * attacking the same cell twice.*/\n\n\n//# sourceURL=webpack://odin_javascript_7_battleship/./src/player.js?");

/***/ }),

/***/ "./src/ship.js":
/*!*********************!*\
  !*** ./src/ship.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**A ship has an id and a set of coordinates.\n * The id is a string like 'carrier'.\n * The coords will be array of objects, each  having x, y, and hit values like\n * [{x: 0, y: 0, hit: false}, {x: 0, y: 1, hit: true}, {x: 0, y: 2, shot: false}]\n */\nconst ship = (id, coordinates) => {\n  let coords = coordinates;\n\n  function getID() {\n    return id;\n  }\n\n  function getCoords() {\n    return coords;\n  }\n\n  function getLength() {\n    return coords.length;\n  }\n\n  /**location input will have the structure: {x:0, y:0}*/\n  function hit(location) {\n    coords.forEach((coord) => {\n      if (coord['x'] === location['x'] && coord['y'] === location['y']) {\n        // if (coord == location) {\n        coord['hit'] = true;\n      }\n    });\n  }\n\n  function isSunk() {\n    return coords.every((coord) => {\n      return coord['hit'] === true;\n    });\n  }\n\n  return { getID, getCoords, getLength, hit, isSunk };\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ship);\n\n\n//# sourceURL=webpack://odin_javascript_7_battleship/./src/ship.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;